<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minecraft 3D – Single File</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
      }
    }
  </script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      margin-left: -5px;
      margin-top: -5px;
      border: 2px solid white;
      border-radius: 50%;
      pointer-events: none;
    }
    #hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      color: rgba(255,255,255,0.92);
      text-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }
    #hint {
      position: fixed;
      top: 14px;
      left: 14px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      max-width: 520px;
      line-height: 1.35;
      font-size: 13px;
    }
    #hint b { color: #fff; }
    #stats {
      position: fixed;
      top: 14px;
      right: 14px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      font-size: 13px;
      min-width: 160px;
      text-align: right;
      white-space: pre;
    }
    #hpBar {
      position: fixed;
      left: 14px;
      bottom: 56px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      font-size: 14px;
      letter-spacing: 1px;
    }
    #hpBar span {
      margin-right: 1px;
    }
    .heart-full { color: #ff4d4d; }
    .heart-empty { color: rgba(255,255,255,0.25); }
    #invBtn {
      position: fixed;
      left: 50%;
      top: 14px;
      transform: translateX(-50%);
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(0,0,0,0.4);
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      pointer-events: auto;
    }
    #inventory {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.45);
      pointer-events: none;
    }
    #inventory .panel {
      pointer-events: auto;
      min-width: 260px;
      padding: 14px 16px;
      border-radius: 12px;
      background: rgba(10,10,10,0.9);
      color: #fff;
      font-size: 13px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.6);
    }
    #inventory .inv-row {
      display: flex;
      gap: 6px;
      margin: 4px 0 8px;
    }
    #inventory .inv-slot {
      width: 52px;
      height: 52px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.03);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      font-size: 11px;
    }
    #inventory .inv-item {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: grab;
      user-select: none;
    }
    #inventory .inv-item.empty {
      opacity: 0.35;
      cursor: default;
    }
    #inventory .inv-count {
      position: absolute;
      right: 4px;
      bottom: 2px;
      font-size: 10px;
      opacity: 0.9;
    }
    #inventory h3 {
      margin: 0 0 8px;
      font-size: 15px;
    }
    #inventory .row {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
    }
    #inventory .craft-cell {
      background: rgba(255,255,255,0.02);
    }
    #inventory .craft-item {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      user-select: none;
    }
    #inventory button {
      margin-top: 8px;
      width: 100%;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-size: 13px;
    }
    #inventory button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    #hpBar {
      position: fixed;
      left: 14px;
      bottom: 18px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      font-size: 14px;
      letter-spacing: 1px;
    }
    #hpBar span {
      margin-right: 1px;
    }
    .heart-full { color: #ff4d4d; }
    .heart-empty { color: rgba(255,255,255,0.25); }
    #hotbar {
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      padding: 10px;
      border-radius: 14px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      pointer-events: none;
    }
    #hitOverlay {
      position: fixed;
      inset: 0;
      background: rgba(255,0,0,0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.08s linear;
    }
    .slot {
      width: 54px;
      height: 54px;
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.05);
      display: grid;
      place-items: center;
      position: relative;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    .slot.active {
      border-color: rgba(255,255,255,0.95);
      box-shadow: 0 0 0 3px rgba(255,255,255,0.15), inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    .slot .num {
      position: absolute;
      left: 6px;
      top: 4px;
      font-size: 12px;
      opacity: 0.9;
    }
    .slot .name {
      position: absolute;
      left: 6px;
      right: 6px;
      bottom: 5px;
      font-size: 11px;
      opacity: 0.9;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .swatch {
      width: 26px;
      height: 26px;
      border-radius: 7px;
      border: 2px solid rgba(255,255,255,0.35);
      box-shadow: 0 3px 10px rgba(0,0,0,0.35);
    }
  </style>
</head>
<body>
<div id="crosshair"></div>
<div id="hud">
  <div id="hint">
    <div><b>Click</b> để khóa chuột / nhìn xung quanh (ESC để thoát).</div>
    <div><b>WASD</b> di chuyển • <b>Space</b> nhảy • <b>Shift</b> chạy nhanh</div>
    <div><b>Chuột trái</b> phá block • <b>Chuột phải</b> đặt block</div>
    <div><b>1-6</b> chọn block trong hotbar</div>
  </div>
  <div id="stats"></div>
  <div id="hotbar"></div>
  <div id="hpBar"></div>
  <button id="invBtn">Túi đồ / Chế tạo (I)</button>
  <div id="inventory">
    <div class="panel"></div>
  </div>
  <div id="hitOverlay"></div>
</div>

<script type="module">
/* ================== IMPORT ================== */
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

/* ================== CORE ================== */
const scene = new THREE.Scene();
const daySky = new THREE.Color(0x87ceeb);
const nightSky = new THREE.Color(0x020410);
scene.background = daySky.clone();
scene.fog = new THREE.Fog(daySky.clone(), 20, 120);

const camera = new THREE.PerspectiveCamera(
  75, window.innerWidth / window.innerHeight, 0.1, 300
);
camera.position.set(0, 2.6, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================== LIGHT / SUN & MOON ================== */
const hemi = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(10, 20, 10);
sun.castShadow = false;
scene.add(sun);

const sunSphere = new THREE.Mesh(
  new THREE.SphereGeometry(2, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xfff8c0 })
);
scene.add(sunSphere);

const moonSphere = new THREE.Mesh(
  new THREE.SphereGeometry(1.6, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xdde6ff })
);
scene.add(moonSphere);

/* ================== CONTROLS ================== */
const controls = new PointerLockControls(camera, document.body);
document.body.addEventListener('click', (e) => {
  // đang mở túi đồ / click lên UI thì không lock chuột
  if (window.inventoryOpen) return;
  if (e.target instanceof HTMLElement && e.target.closest('#inventory')) return;
  controls.lock();
});
scene.add(controls.getObject());

/* ================== WORLD DATA ================== */
const world = new Map(); // key = "x,y,z" -> type
let renderDirty = true;
const instancedByType = new Map(); // type -> InstancedMesh
const chunkBlocks = new Map(); // chunkKey -> danh sách block thuộc chunk đó
const loadedChunks = new Set(); // tập các chunkKey đã load

const BlockType = {
  GRASS: 'grass',
  DIRT: 'dirt',
  STONE: 'stone',
  SAND: 'sand',
  WOOD: 'wood',
  LEAVES: 'leaves',
  WATER: 'water',
  BEDROCK: 'bedrock',
};

const blockPalette = [
  { type: BlockType.GRASS, name: 'Grass', color: 0x4fa34f },
  { type: BlockType.DIRT, name: 'Dirt', color: 0x8b5a2b },
  { type: BlockType.STONE, name: 'Stone', color: 0x8f8f8f },
  { type: BlockType.SAND, name: 'Sand', color: 0xd8c58a },
  { type: BlockType.WOOD, name: 'Wood', color: 0x7b4f2a },
  { type: BlockType.LEAVES, name: 'Leaves', color: 0x2f7d3a },
  { type: BlockType.WATER, name: 'Water', color: 0x2b66c9 },
];

let selectedSlot = 0;
const ui = {
  stats: document.getElementById('stats'),
  hotbar: document.getElementById('hotbar'),
  hpBar: document.getElementById('hpBar'),
  invBtn: document.getElementById('invBtn'),
  inventory: document.querySelector('#inventory .panel'),
  hitOverlay: document.getElementById('hitOverlay'),
};

/* ================== BLOCKS ================== */
const blockGeo = new THREE.BoxGeometry(1, 1, 1);

function key(x,y,z){ return `${x},${y},${z}` }
function isSolid(type){ return !!type; }
function parseKey(k){
  const a = k.indexOf(',');
  const b = k.indexOf(',', a + 1);
  return [
    Number(k.slice(0, a)),
    Number(k.slice(a + 1, b)),
    Number(k.slice(b + 1)),
  ];
}

/* ================== PIXEL TEXTURES (NO EXTERNAL IMAGES) ================== */
function clamp01(t){ return Math.max(0, Math.min(1, t)); }
function mix(a, b, t){ return a + (b - a) * t; }
function hexToRgb(hex){
  return {
    r: (hex >> 16) & 255,
    g: (hex >> 8) & 255,
    b: hex & 255,
  };
}
function hash3(x, y, s){
  let n = (x * 374761393 + y * 668265263 + s * 2147483647) >>> 0;
  n = (n ^ (n >> 13)) * 1274126177;
  n = (n ^ (n >> 16)) >>> 0;
  return n / 4294967296;
}
function makeCanvasTexture(draw){
  const c = document.createElement('canvas');
  c.width = 16; c.height = 16;
  const ctx = c.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  draw(ctx);
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestMipmapNearestFilter;
  tex.generateMipmaps = true;
  tex.needsUpdate = true;
  return tex;
}
function fillNoise(ctx, baseHex, seed, variance = 0.18, alpha = 1){
  const base = hexToRgb(baseHex);
  const img = ctx.createImageData(16, 16);
  for(let y=0;y<16;y++){
    for(let x=0;x<16;x++){
      const t = (hash3(x, y, seed) - 0.5) * 2; // -1..1
      const k = clamp01(1 + t * variance);
      const i = (y * 16 + x) * 4;
      img.data[i+0] = Math.round(base.r * k);
      img.data[i+1] = Math.round(base.g * k);
      img.data[i+2] = Math.round(base.b * k);
      img.data[i+3] = Math.round(alpha * 255);
    }
  }
  ctx.putImageData(img, 0, 0);
}

const texDirt = makeCanvasTexture(ctx => fillNoise(ctx, 0x7a4f2a, 11, 0.22));
const texStone = makeCanvasTexture(ctx => fillNoise(ctx, 0x8c8c8c, 22, 0.22));
const texSand  = makeCanvasTexture(ctx => fillNoise(ctx, 0xd8c58a, 33, 0.14));
const texGrassTop = makeCanvasTexture(ctx => fillNoise(ctx, 0x4fa34f, 44, 0.20));
const texGrassSide = makeCanvasTexture(ctx => {
  // top band green, bottom dirt
  fillNoise(ctx, 0x7a4f2a, 55, 0.18);
  const band = ctx.getImageData(0, 0, 16, 5);
  for(let i=0;i<band.data.length;i+=4){
    // overwrite with greenish noise
    const px = (i/4) % 16;
    const py = Math.floor((i/4) / 16);
    const t = (hash3(px, py, 56) - 0.5) * 2;
    const k = clamp01(1 + t * 0.22);
    band.data[i+0] = Math.round(90 * k);
    band.data[i+1] = Math.round(175 * k);
    band.data[i+2] = Math.round(95 * k);
    band.data[i+3] = 255;
  }
  ctx.putImageData(band, 0, 0);
});
const texWoodSide = makeCanvasTexture(ctx => {
  fillNoise(ctx, 0x7b4f2a, 66, 0.18);
  // simple vertical stripes
  const img = ctx.getImageData(0, 0, 16, 16);
  for(let y=0;y<16;y++){
    for(let x=0;x<16;x++){
      const i = (y * 16 + x) * 4;
      const stripe = (x % 4 === 0) ? 0.86 : 1.0;
      img.data[i+0] = Math.round(img.data[i+0] * stripe);
      img.data[i+1] = Math.round(img.data[i+1] * stripe);
      img.data[i+2] = Math.round(img.data[i+2] * stripe);
    }
  }
  ctx.putImageData(img, 0, 0);
});
const texWoodTop = makeCanvasTexture(ctx => {
  fillNoise(ctx, 0x8a5a2f, 77, 0.12);
  // rings
  const img = ctx.getImageData(0, 0, 16, 16);
  for(let y=0;y<16;y++){
    for(let x=0;x<16;x++){
      const dx = x - 7.5, dy = y - 7.5;
      const d = Math.sqrt(dx*dx + dy*dy);
      const ring = (Math.floor(d) % 3 === 0) ? 0.80 : 1.0;
      const i = (y * 16 + x) * 4;
      img.data[i+0] = Math.round(img.data[i+0] * ring);
      img.data[i+1] = Math.round(img.data[i+1] * ring);
      img.data[i+2] = Math.round(img.data[i+2] * ring);
    }
  }
  ctx.putImageData(img, 0, 0);
});
const texLeaves = makeCanvasTexture(ctx => {
  // green with alpha holes
  const img = ctx.createImageData(16, 16);
  for(let y=0;y<16;y++){
    for(let x=0;x<16;x++){
      const t = (hash3(x, y, 88) - 0.5) * 2;
      const k = clamp01(1 + t * 0.25);
      const hole = hash3(x, y, 89);
      const a = hole > 0.14 ? 1 : 0; // alpha test will cut it out
      const i = (y * 16 + x) * 4;
      img.data[i+0] = Math.round(50 * k);
      img.data[i+1] = Math.round(140 * k);
      img.data[i+2] = Math.round(70 * k);
      img.data[i+3] = Math.round(a * 255);
    }
  }
  ctx.putImageData(img, 0, 0);
});

// Simple water texture: blue with slight variation and alpha
const texWater = makeCanvasTexture(ctx => {
  const baseHex = 0x2b66c9;
  const base = hexToRgb(baseHex);
  const img = ctx.createImageData(16, 16);
  for(let y=0;y<16;y++){
    for(let x=0;x<16;x++){
      const t = (hash3(x, y, 95) - 0.5) * 2;
      const k = clamp01(1 + t * 0.20);
      const i = (y * 16 + x) * 4;
      img.data[i+0] = Math.round(base.r * k);
      img.data[i+1] = Math.round(base.g * k);
      img.data[i+2] = Math.round(base.b * k);
      img.data[i+3] = 200; // alpha ~0.78
    }
  }
  ctx.putImageData(img, 0, 0);
});

function mat(map, extra = {}){
  return new THREE.MeshLambertMaterial({ map, ...extra });
}

const materialCache = new Map();
materialCache.set(BlockType.DIRT, mat(texDirt));
materialCache.set(BlockType.STONE, mat(texStone));
materialCache.set(BlockType.BEDROCK, mat(texStone)); // dùng texture đá cho bedrock
materialCache.set(BlockType.SAND, mat(texSand));
materialCache.set(BlockType.LEAVES, mat(texLeaves, { transparent: true, alphaTest: 0.4, side: THREE.DoubleSide }));
materialCache.set(BlockType.WATER, mat(texWater, { transparent: true, depthWrite: false, opacity: 0.8 }));
materialCache.set(BlockType.GRASS, [
  mat(texGrassSide), // +x
  mat(texGrassSide), // -x
  mat(texGrassTop),  // +y
  mat(texDirt),      // -y
  mat(texGrassSide), // +z
  mat(texGrassSide), // -z
]);
materialCache.set(BlockType.WOOD, [
  mat(texWoodSide),
  mat(texWoodSide),
  mat(texWoodTop),
  mat(texWoodTop),
  mat(texWoodSide),
  mat(texWoodSide),
]);

/* ================== MOBS (ZOMBIE + SKELETON) ================== */
const mobs = []; // { mesh, type, hp, lastAttackTime }
const MobType = {
  ZOMBIE: 'zombie',
  SKELETON: 'skeleton',
};

const mobBodyGeo = new THREE.BoxGeometry(0.8, 1.4, 0.8);
const mobHeadGeo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
const mobBodyMat = new THREE.MeshLambertMaterial({ color: 0x2d5f2d });   // zombie áo xanh
const mobHeadMat = new THREE.MeshLambertMaterial({ color: 0x9bbf8c });   // zombie da xanh
const skelBodyMat = new THREE.MeshLambertMaterial({ color: 0x808080 });  // skeleton áo xám
const skelHeadMat = new THREE.MeshLambertMaterial({ color: 0xf4f4f4 });  // skeleton đầu trắng

let playerHP = 20;
// Túi đồ đơn giản với một số item cơ bản
const inventory = {
  log: 0,            // gỗ thân cây
  plank: 0,          // ván gỗ
  stick: 0,          // que gỗ
  crafting_table: 0, // bàn chế tạo
  rotten_flesh: 0,   // thịt thối
  wood_sword: 0,     // kiếm gỗ
};
let hasWoodSword = false;
let lastAttackTimePlayer = 0;
const ATTACK_COOLDOWN = 0.4; // giây
let inventoryOpen = false;

const projectiles = []; // mũi tên từ skeleton
const arrowGeo = new THREE.BoxGeometry(0.12, 0.12, 0.9);
const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffe0a0 });
const ARROW_GRAVITY = 18;
let hitOverlayAlpha = 0;

function spawnZombieAt(x, z){
  const h = heightAt(x, z);
  const groundType = getBlock(x, h, z);
  if(groundType === BlockType.WATER || !groundType) return;

  const group = new THREE.Group();
  const body = new THREE.Mesh(mobBodyGeo, mobBodyMat);
  const head = new THREE.Mesh(mobHeadGeo, mobHeadMat);
  body.position.set(0, 0.7, 0);
  head.position.set(0, 1.6, 0);
  group.add(body);
  group.add(head);
  group.position.set(x + 0.5, h, z + 0.5);
  scene.add(group);

  mobs.push({
    mesh: group,
    type: MobType.ZOMBIE,
    hp: 20,
    lastAttackTime: 0,
  });
}

function spawnSkeletonAt(x, z){
  const h = heightAt(x, z);
  const groundType = getBlock(x, h, z);
  if(groundType === BlockType.WATER || !groundType) return;

  const group = new THREE.Group();
  const body = new THREE.Mesh(mobBodyGeo, skelBodyMat);
  const head = new THREE.Mesh(mobHeadGeo, skelHeadMat);
  body.position.set(0, 0.7, 0);
  head.position.set(0, 1.6, 0);
  group.add(body);
  group.add(head);
  group.position.set(x + 0.5, h, z + 0.5);
  scene.add(group);

  mobs.push({
    mesh: group,
    type: MobType.SKELETON,
    hp: 20,
    lastAttackTime: 0,
  });
}

function trySpawnMobs(delta){
  // chỉ spawn ban đêm, khi trời đủ tối
  const NIGHT_BRIGHTNESS_THRESHOLD = 0.3;
  // brightness được tính trong animate, nhưng ta ước lượng từ vị trí mặt trời (y < 0)
  const sunY = sun.position.y;
  const approxBrightness = Math.max(0, sunY / 50);
  if(approxBrightness > NIGHT_BRIGHTNESS_THRESHOLD) return;

  // giới hạn tổng số mob tối đa quanh người chơi
  const MAX_MOBS = 16;
  if(mobs.length >= MAX_MOBS) return;

  // xác suất spawn nhỏ mỗi frame
  if(Math.random() > 0.02) return;

  const p = controls.getObject().position;
  const minDist = 18;
  const maxDist = 35;
  const angle = Math.random() * Math.PI * 2;
  const dist = minDist + Math.random() * (maxDist - minDist);
  const x = Math.floor(p.x + Math.cos(angle) * dist);
  const z = Math.floor(p.z + Math.sin(angle) * dist);

  // 60% zombie, 40% skeleton
  if(Math.random() < 0.6){
    spawnZombieAt(x, z);
  } else {
    spawnSkeletonAt(x, z);
  }
}

function updateMobs(delta){
  const p = controls.getObject().position;
  const now = worldTime;
  const newMobs = [];

  for(const mob of mobs){
    const mpos = mob.mesh.position;
    const dx = p.x - mpos.x;
    const dz = p.z - mpos.z;
    const distXZ = Math.hypot(dx, dz);

    // loại bỏ zombie quá xa (ngoài tầm chunk render) để nhẹ máy
    const maxKeepDist = (VIEW_DISTANCE_CHUNKS + 2) * CHUNK_SIZE;
    if(distXZ > maxKeepDist){
      scene.remove(mob.mesh);
      continue;
    }

    if(mob.type === MobType.ZOMBIE){
      // di chuyển đơn giản về phía người chơi theo mặt phẳng XZ (cận chiến)
      if(distXZ > 1.2){
        const speed = 3.2; // block/s
        const vx = (dx / distXZ) * speed * delta;
        const vz = (dz / distXZ) * speed * delta;

        const nextX = mpos.x + vx;
        const nextZ = mpos.z + vz;
        const groundY = heightAt(Math.floor(nextX), Math.floor(nextZ));
        mob.mesh.position.set(nextX, groundY, nextZ);
      }
    } else if(mob.type === MobType.SKELETON){
      // skeleton giữ khoảng cách: tới gần thì lùi, xa quá thì tiến lại
      const minDist = 7;
      const maxDist = 14;
      let vx = 0, vz = 0;
      const speed = 3.0;
      if(distXZ < minDist){
        // lùi ra
        vx = -(dx / distXZ) * speed * delta;
        vz = -(dz / distXZ) * speed * delta;
      } else if(distXZ > maxDist){
        // tiến lại
        vx = (dx / distXZ) * speed * delta;
        vz = (dz / distXZ) * speed * delta;
      }
      if(vx !== 0 || vz !== 0){
        const nextX = mpos.x + vx;
        const nextZ = mpos.z + vz;
        const groundY = heightAt(Math.floor(nextX), Math.floor(nextZ));
        mob.mesh.position.set(nextX, groundY, nextZ);
      }

      // skeleton bắn tên khi trong tầm nhìn (tầm bắn ngắn hơn)
      const minShoot = 5;
      const maxShoot = 14;
      if(distXZ > minShoot && distXZ < maxShoot && now - mob.lastAttackTime > 1.4){
        mob.lastAttackTime = now;
        const dir = new THREE.Vector3(dx, 0.6, dz).normalize();
        spawnArrow(mpos.clone().add(new THREE.Vector3(0, 1.4, 0)), dir);
      }
    }

    // zombie cháy dưới nắng ban ngày
    const sunY = sun.position.y;
    const approxBrightness = Math.max(0, sunY / 50);
    const FOOT_Y = Math.floor(mpos.y);
    const groundHere = getBlock(Math.floor(mpos.x), FOOT_Y, Math.floor(mpos.z));
    const inWater = groundHere === BlockType.WATER;
    if(approxBrightness > 0.35 && sunY > 0 && !inWater){
      mob.hp -= 6 * delta; // giảm máu từ từ
    }

    if(mob.hp <= 0){
      // rớt đồ khi chết
      const dropRoll = Math.random();
      if(dropRoll < 0.7){
        inventory.rotten_flesh += 1 + (Math.random() < 0.4 ? 1 : 0);
      }
      if(dropRoll > 0.6 && dropRoll < 0.8){
        inventory.log += 1;
      }
      scene.remove(mob.mesh);
      continue;
    }

    // zombie gây sát thương khi lại gần
    if(mob.type === MobType.ZOMBIE && distXZ < 1.4 && now - mob.lastAttackTime > 0.7){
      mob.lastAttackTime = now;
      playerHP = Math.max(0, playerHP - 1);
      triggerHitOverlay();
    }

    newMobs.push(mob);
  }

  mobs.length = 0;
  mobs.push(...newMobs);
}

function spawnArrow(origin, dir){
  const mesh = new THREE.Mesh(arrowGeo, arrowMat);
  mesh.position.copy(origin);
  scene.add(mesh);
  const vel = dir.clone().normalize().multiplyScalar(16);
  projectiles.push({ mesh, vel, life: 2.2 });
}

function updateProjectiles(delta){
  const p = controls.getObject().position;
  const remaining = [];
  for(const proj of projectiles){
    proj.life -= delta;
    if(proj.life <= 0){
      scene.remove(proj.mesh);
      continue;
    }
    // áp dụng trọng lực cho mũi tên
    proj.vel.y -= ARROW_GRAVITY * delta;
    proj.mesh.position.addScaledVector(proj.vel, delta);

    // va chạm với thế giới
    const px = Math.round(proj.mesh.position.x);
    const py = Math.round(proj.mesh.position.y);
    const pz = Math.round(proj.mesh.position.z);
    const b = getBlock(px, py, pz);
    if(b && b !== BlockType.WATER){
      scene.remove(proj.mesh);
      continue;
    }

    // va chạm với người chơi
    const dx = proj.mesh.position.x - p.x;
    const dy = proj.mesh.position.y - p.y;
    const dz = proj.mesh.position.z - p.z;
    if(Math.sqrt(dx*dx + dy*dy + dz*dz) < 1.2){
      playerHP = Math.max(0, playerHP - 4);
      triggerHitOverlay();
      scene.remove(proj.mesh);
      continue;
    }

    remaining.push(proj);
  }
  projectiles.length = 0;
  projectiles.push(...remaining);
}

function getMaterialForType(type){
  return materialCache.get(type) ?? materialCache.get(BlockType.DIRT);
}

function getBlock(x,y,z){
  return world.get(key(x,y,z)) ?? null;
}

function addBlock(x,y,z,type){
  if(!Number.isInteger(x) || !Number.isInteger(y) || !Number.isInteger(z)) return;
  const k = key(x,y,z);
  if(world.has(k)) return;
  world.set(k, type);

  // gắn block mới vào chunk tương ứng (để load/unload hoạt động đúng)
  const cx = Math.floor(x / CHUNK_SIZE);
  const cz = Math.floor(z / CHUNK_SIZE);
  const chunkKey = `${cx},${cz}`;
  let list = chunkBlocks.get(chunkKey);
  if(!list){
    list = [];
    chunkBlocks.set(chunkKey, list);
  }
  list.push(k);

  renderDirty = true;
}

function removeBlockAt(x,y,z){
  const k = key(x,y,z);
  const t = getBlock(x,y,z);
  if(t === BlockType.BEDROCK) return null; // không cho phá bedrock
  const existed = world.delete(k);
  if(existed){
    // xóa khỏi danh sách block của chunk
    const cx = Math.floor(x / CHUNK_SIZE);
    const cz = Math.floor(z / CHUNK_SIZE);
    const chunkKey = `${cx},${cz}`;
    const list = chunkBlocks.get(chunkKey);
    if(list){
      const idx = list.indexOf(k);
      if(idx !== -1) list.splice(idx, 1);
    }
    renderDirty = true;
  }
  // trả về loại block đã xóa (hoặc null nếu không xóa được)
  return existed ? t : null;
}

function rebuildInstances(){
  // remove old meshes
  for(const mesh of instancedByType.values()) scene.remove(mesh);
  instancedByType.clear();

  const positionsByType = new Map(blockPalette.map(p => [p.type, []]));
  for(const [k, type] of world.entries()){
    const arr = positionsByType.get(type);
    if(!arr) continue;
    arr.push(k);
  }

  const m = new THREE.Matrix4();
  for(const [type, keysArr] of positionsByType.entries()){
    const count = keysArr.length;
    if(count === 0) continue;
    const inst = new THREE.InstancedMesh(blockGeo, getMaterialForType(type), count);
    inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    for(let i=0;i<count;i++){
      const [x,y,z] = parseKey(keysArr[i]);
      m.makeTranslation(x, y, z);
      inst.setMatrixAt(i, m);
    }
    inst.instanceMatrix.needsUpdate = true;
    inst.receiveShadow = true;
    inst.castShadow = false;
    scene.add(inst);
    instancedByType.set(type, inst);
  }
}

/* ================== OUTLINE (TARGET) ================== */
const outline = new THREE.LineSegments(
  new THREE.EdgesGeometry(blockGeo),
  new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 })
);
outline.visible = false;
scene.add(outline);

/* ================== UI (HOTBAR) ================== */
function renderHotbar(){
  ui.hotbar.innerHTML = '';
  for(let i=0;i<blockPalette.length;i++){
    const p = blockPalette[i];
    const slot = document.createElement('div');
    slot.className = 'slot' + (i === selectedSlot ? ' active' : '');
    slot.innerHTML = `
      <div class="num">${i+1}</div>
      <div class="swatch" style="background:${'#' + p.color.toString(16).padStart(6,'0')}"></div>
      <div class="name">${p.name}</div>
    `;
    ui.hotbar.appendChild(slot);
  }
}
renderHotbar();

function renderHPBar(){
  const maxHearts = 10; // 20 HP = 10 tim
  const hp = Math.max(0, Math.min(20, playerHP));
  const fullHearts = Math.floor(hp / 2);
  const halfHeart = hp % 2;
  let html = '';
  for(let i=0;i<maxHearts;i++){
    if(i < fullHearts){
      html += '<span class="heart-full">♥</span>';
    } else if(i === fullHearts && halfHeart){
      html += '<span class="heart-full">♡</span>';
    } else {
      html += '<span class="heart-empty">♥</span>';
    }
  }
  ui.hpBar.innerHTML = html;
}

function triggerHitOverlay(){
  hitOverlayAlpha = 0.5;
  if(ui.hitOverlay){
    ui.hitOverlay.style.opacity = String(hitOverlayAlpha);
  }
}

function renderInventory(){
  ui.inventory.innerHTML = `
    <h3>Túi đồ & Bàn chế tạo 3×3</h3>
    <div style="margin:0 0 4px;font-size:12px;opacity:0.8;">
      Kéo thả item giữa túi đồ và lưới chế tạo.
    </div>
    <div id="invItems" class="inv-row"></div>
    <div style="margin:6px 0 4px;font-size:12px;opacity:0.8;">
      Bàn chế tạo 3×3 (L = Log, P = Plank, S = Stick, T = Bàn, K = Kiếm)
    </div>
    <div id="craftGrid" style="display:grid;grid-template-columns:repeat(3,28px);grid-gap:4px;margin-bottom:8px;"></div>
    <div class="row" style="align-items:center;margin-bottom:6px;">
      <span>Kết quả:</span>
      <span id="craftResult" style="min-width:120px;text-align:right;"></span>
    </div>
    <div class="row" style="gap:6px;margin-bottom:4px;">
      <button id="craftOnceBtn" style="margin-top:0;flex:1;" disabled>Chế tạo 1 lần (theo lưới)</button>
    </div>
    <div style="margin-top:4px;font-size:11px;opacity:0.9;line-height:1.5;">
      <b>Chế tạo nhanh (không cần xếp mẫu)</b>
      <div style="display:flex;flex-direction:column;gap:4px;margin-top:4px;">
        <button id="quickPlankBtn" style="margin-top:0;width:100%;font-size:11px;"></button>
        <button id="quickStickBtn" style="margin-top:0;width:100%;font-size:11px;"></button>
        <button id="quickTableBtn" style="margin-top:0;width:100%;font-size:11px;"></button>
        <button id="quickSwordBtn" style="margin-top:0;width:100%;font-size:11px;"></button>
      </div>
    </div>
    <div style="margin-top:6px;font-size:11px;opacity:0.8;line-height:1.4;">
      <b>Sổ công thức cơ bản</b><br/>
      - 1 Log → 4 Plank (đặt 1 Log bất kỳ ô nào, các ô khác trống).<br/>
      - 2 Plank dọc → 4 Stick (2 ô dọc liền nhau, các ô khác trống).<br/>
      - 4 Plank hình vuông 2×2 → 1 Bàn chế tạo.<br/>
      - Kiếm gỗ: Plank ở (hàng 1,2 cột giữa) + Stick ở (hàng 3 cột giữa).<br/>
      Chuột trái: Đánh quái / phá block • I để đóng/mở túi đồ
    </div>
  `;

  // render túi đồ (inventory)
  const invEl = document.getElementById('invItems');
  if(invEl){
    invEl.innerHTML = '';
    const items = [
      { key: 'log',            label: 'Log' },
      { key: 'plank',          label: 'Plank' },
      { key: 'stick',          label: 'Stick' },
      { key: 'crafting_table', label: 'Bàn chế tạo' },
      { key: 'rotten_flesh',   label: 'Thịt thối' },
      { key: 'wood_sword',     label: 'Kiếm gỗ' },
    ];
    for(const info of items){
      const count = inventory[info.key] ?? 0;
      const slot = document.createElement('div');
      slot.className = 'inv-slot';

      const itemEl = document.createElement('div');
      itemEl.className = 'inv-item' + (count === 0 ? ' empty' : '');
      itemEl.textContent = info.label;

      const countEl = document.createElement('div');
      countEl.className = 'inv-count';
      countEl.textContent = String(count);

      if(count > 0){
        const setupDrag = (el) => {
          el.draggable = true;
          el.dataset.item = info.key;
          el.addEventListener('dragstart', (ev) => {
            const curCount = inventory[info.key] ?? 0;
            if(curCount <= 0 || !ev.dataTransfer) return;
            ev.dataTransfer.effectAllowed = 'move';
            ev.dataTransfer.setData('text/plain', JSON.stringify({
              from: 'inv',
              item: info.key,
            }));
          });
        };
        // cho phép kéo cả ô lẫn nhãn
        setupDrag(itemEl);
        setupDrag(slot);
      }

      slot.appendChild(itemEl);
      slot.appendChild(countEl);
      invEl.appendChild(slot);
    }

    // nhận item kéo từ lưới chế tạo trả về túi (gán one-shot, tránh nhân nhiều listener)
    invEl.ondragover = (ev) => {
      ev.preventDefault();
      if(ev.dataTransfer) ev.dataTransfer.dropEffect = 'move';
    };
    invEl.ondrop = (ev) => {
      ev.preventDefault();
      if(!ev.dataTransfer) return;
      const txt = ev.dataTransfer.getData('text/plain');
      if(!txt) return;
      let data;
      try { data = JSON.parse(txt); } catch { return; }
      if(data.from === 'craft'){
        const idx = Number(data.index);
        if(Number.isNaN(idx)) return;
        if(!window.craftGrid) return;
        const keyInGrid = window.craftGrid[idx];
        if(!keyInGrid) return;
        window.craftGrid[idx] = null;
        if(Object.prototype.hasOwnProperty.call(inventory, keyInGrid)){
          inventory[keyInGrid] += 1;
        }
        renderInventory();
      }
    };
  }

  // khởi tạo lưới 3×3
  if(typeof window.craftGrid === 'undefined'){
    window.craftGrid = new Array(9).fill(null);
  }
  const gridEl = document.getElementById('craftGrid');
  gridEl.innerHTML = '';
  for(let i=0;i<9;i++){
    const cell = document.createElement('div');
    cell.dataset.index = String(i);
    cell.className = 'craft-cell';
    cell.style.width = '28px';
    cell.style.height = '28px';
    cell.style.borderRadius = '4px';
    cell.style.border = '1px solid rgba(255,255,255,0.3)';
    cell.style.display = 'flex';
    cell.style.alignItems = 'center';
    cell.style.justifyContent = 'center';
    cell.style.fontSize = '11px';
    cell.style.cursor = 'pointer';
    gridEl.appendChild(cell);
  }

  function renderCraftGrid(){
    for(let i=0;i<9;i++){
      const cell = gridEl.querySelector(`div[data-index="${i}"]`);
      if(!cell) continue;
      const v = window.craftGrid[i];
      cell.innerHTML = '';
      if(!v){
        cell.style.background = 'transparent';
        cell.style.borderColor = 'rgba(255,255,255,0.3)';
      }else{
        let bg = 'rgba(255,255,255,0.08)';
        if(v === 'log') bg = 'rgba(139,69,19,0.55)';               // nâu đậm
        else if(v === 'plank') bg = 'rgba(222,184,135,0.55)';      // nâu vàng
        else if(v === 'stick') bg = 'rgba(210,180,140,0.55)';      // be nhạt
        else if(v === 'crafting_table') bg = 'rgba(180,120,80,0.6)'; // nâu hơi đỏ
        else if(v === 'rotten_flesh') bg = 'rgba(190,70,70,0.45)'; // đỏ
        else if(v === 'wood_sword') bg = 'rgba(200,200,200,0.45)'; // xám nhạt
        cell.style.background = bg;
        cell.style.borderColor = 'rgba(255,255,255,0.9)';
      }
      if(v){
        const itemEl = document.createElement('div');
        itemEl.className = 'craft-item';
        // nhãn ngắn theo loại item
        let label = '?';
        let title = v;
        if(v === 'log'){ label = 'L'; title = 'Log (thân cây)'; }
        else if(v === 'plank'){ label = 'P'; title = 'Plank (ván gỗ)'; }
        else if(v === 'stick'){ label = 'S'; title = 'Stick (que gỗ)'; }
        else if(v === 'crafting_table'){ label = 'T'; title = 'Bàn chế tạo'; }
        else if(v === 'rotten_flesh'){ label = 'F'; title = 'Thịt thối'; }
        else if(v === 'wood_sword'){ label = 'K'; title = 'Kiếm gỗ'; }
        itemEl.textContent = label;
        itemEl.title = title;
        itemEl.draggable = true;
        itemEl.addEventListener('dragstart', (ev) => {
          if(!ev.dataTransfer) return;
          ev.dataTransfer.effectAllowed = 'move';
          ev.dataTransfer.setData('text/plain', JSON.stringify({
            from: 'craft',
            item: v,
            index: i,
          }));
        });
        cell.appendChild(itemEl);
      }
    }
  }

  // phát hiện công thức dựa trên lưới 3×3 hiện tại
  function detectRecipe(){
    const g = window.craftGrid;
    // đếm số lượng từng loại cơ bản
    let logCount = 0, plankCount = 0, stickCount = 0, otherCount = 0;
    for(const v of g){
      if(!v) continue;
      if(v === 'log') logCount++;
      else if(v === 'plank') plankCount++;
      else if(v === 'stick') stickCount++;
      else otherCount++;
    }

    // 1) 1 log duy nhất → 4 plank
    if(logCount === 1 && plankCount === 0 && stickCount === 0 && otherCount === 0){
      return { item: 'plank', count: 4, label: 'Plank ×4' };
    }

    // 2) 2 plank dọc liền nhau, các ô khác trống → 4 stick
    if(plankCount === 2 && logCount === 0 && stickCount === 0 && otherCount === 0){
      const idxs = [];
      g.forEach((v, i) => { if(v === 'plank') idxs.push(i); });
      if(idxs.length === 2 && idxs[1] - idxs[0] === 3){
        return { item: 'stick', count: 4, label: 'Stick ×4' };
      }
    }

    // 3) 4 plank hình vuông 2×2, các ô khác trống → 1 bàn chế tạo
    if(plankCount === 4 && logCount === 0 && stickCount === 0 && otherCount === 0){
      const idxs = [];
      g.forEach((v, i) => { if(v === 'plank') idxs.push(i); });
      const shapes = [
        [0,1,3,4],
        [1,2,4,5],
        [3,4,6,7],
        [4,5,7,8],
      ];
      const sorted = idxs.slice().sort((a,b)=>a-b).join(',');
      for(const s of shapes){
        if(sorted === s.join(',')){
          return { item: 'crafting_table', count: 1, label: 'Bàn chế tạo ×1' };
        }
      }
    }

    // 4) Kiếm gỗ: plank ở (1,4) + stick ở (7), các ô khác trống
    if(
      g[1] === 'plank' &&
      g[4] === 'plank' &&
      g[7] === 'stick'
    ){
      let used = 0;
      for(let i=0;i<9;i++){
        if(!g[i]) continue;
        if((i === 1 || i === 4) && g[i] === 'plank'){ used++; continue; }
        if(i === 7 && g[i] === 'stick'){ used++; continue; }
        // có thêm item ngoài pattern
        return null;
      }
      if(used === 3){
        return { item: 'wood_sword', count: 1, label: 'Kiếm gỗ ×1' };
      }
    }

    return null;
  }

  // click lên lưới: không thay đổi logic, chỉ bỏ trống để tránh xung đột với drag & drop
  gridEl.onclick = (ev) => {
    // bỏ qua, tránh double-change khi trình duyệt sinh thêm click sau drop
  };

  // drag & drop: nhận item kéo từ túi đồ hoặc di chuyển giữa các ô
  gridEl.ondragover = (ev) => {
    ev.preventDefault();
    if(ev.dataTransfer) ev.dataTransfer.dropEffect = 'move';
  };
  gridEl.ondrop = (ev) => {
    ev.preventDefault();
    if(!ev.dataTransfer) return;
    const txt = ev.dataTransfer.getData('text/plain');
    if(!txt) return;
    let data;
    try { data = JSON.parse(txt); } catch { return; }

    const target = ev.target;
    if(!(target instanceof HTMLElement)) return;
    const cell = target.closest('[data-index]');
    if(!cell) return;
    const idx = Number(cell.dataset.index);
    if(Number.isNaN(idx)) return;

    if(data.from === 'inv'){
      const itemKey = data.item;
      if(!Object.prototype.hasOwnProperty.call(inventory, itemKey)) return;
      if((inventory[itemKey] ?? 0) <= 0) return;
      if(window.craftGrid[idx]) return;
      window.craftGrid[idx] = itemKey;
      inventory[itemKey] -= 1;
      renderInventory();
      return;
    }

    if(data.from === 'craft'){
      const src = Number(data.index);
      if(Number.isNaN(src)) return;
      if(src === idx) return;
      const srcKey = window.craftGrid[src];
      if(!srcKey) return;
      if(window.craftGrid[idx]) return;
      window.craftGrid[src] = null;
      window.craftGrid[idx] = srcKey;
      renderInventory();
      return;
    }
  };

  renderCraftGrid();

  const btn = document.getElementById('craftOnceBtn');
  const resultEl = document.getElementById('craftResult');
  if(btn && resultEl){
    const recipe = detectRecipe();
    const ok = !!recipe;
    btn.disabled = !ok;
    resultEl.textContent = ok ? recipe.label : '';
    btn.onclick = () => {
      const r = detectRecipe();
      if(!r) return;
      if(Object.prototype.hasOwnProperty.call(inventory, r.item)){
        inventory[r.item] += r.count;
        if(r.item === 'wood_sword') hasWoodSword = true;
      }
      // nguyên liệu đã bị trừ khỏi túi khi kéo vào lưới → chỉ cần xóa lưới
      window.craftGrid = new Array(9).fill(null);
      renderInventory();
    };
  }

  // --- Chế tạo nhanh: không cần kéo vào lưới ---
  const quickPlankBtn = document.getElementById('quickPlankBtn');
  const quickStickBtn = document.getElementById('quickStickBtn');
  const quickTableBtn = document.getElementById('quickTableBtn');
  const quickSwordBtn = document.getElementById('quickSwordBtn');

  // 1) Log -> Plank (1 log -> 4 plank), craft tối đa
  if(quickPlankBtn){
    const maxCraft = Math.floor((inventory.log ?? 0) / 1);
    quickPlankBtn.disabled = maxCraft <= 0;
    quickPlankBtn.textContent = maxCraft > 0
      ? `Plank: 1 Log → 4 Plank (tối đa ${maxCraft} lần)`
      : 'Plank: cần ít nhất 1 Log';
    quickPlankBtn.onclick = () => {
      const maxNow = Math.floor((inventory.log ?? 0) / 1);
      if(maxNow <= 0) return;
      inventory.log -= maxNow;
      inventory.plank += maxNow * 4;
      renderInventory();
    };
  }

  // 2) Plank -> Stick (2 plank -> 4 stick), craft tối đa
  if(quickStickBtn){
    const maxCraft = Math.floor((inventory.plank ?? 0) / 2);
    quickStickBtn.disabled = maxCraft <= 0;
    quickStickBtn.textContent = maxCraft > 0
      ? `Stick: 2 Plank → 4 Stick (tối đa ${maxCraft} lần)`
      : 'Stick: cần ít nhất 2 Plank';
    quickStickBtn.onclick = () => {
      const maxNow = Math.floor((inventory.plank ?? 0) / 2);
      if(maxNow <= 0) return;
      inventory.plank -= maxNow * 2;
      inventory.stick += maxNow * 4;
      renderInventory();
    };
  }

  // 3) Bàn chế tạo: 4 plank -> 1 table, craft tối đa
  if(quickTableBtn){
    const maxCraft = Math.floor((inventory.plank ?? 0) / 4);
    quickTableBtn.disabled = maxCraft <= 0;
    quickTableBtn.textContent = maxCraft > 0
      ? `Bàn chế tạo: 4 Plank → 1 Bàn (tối đa ${maxCraft})`
      : 'Bàn chế tạo: cần ít nhất 4 Plank';
    quickTableBtn.onclick = () => {
      const maxNow = Math.floor((inventory.plank ?? 0) / 4);
      if(maxNow <= 0) return;
      inventory.plank -= maxNow * 4;
      inventory.crafting_table += maxNow;
      renderInventory();
    };
  }

  // 4) Kiếm gỗ: 2 plank + 1 stick -> 1 kiếm, craft tối đa
  if(quickSwordBtn){
    const maxByPlank = Math.floor((inventory.plank ?? 0) / 2);
    const maxByStick = inventory.stick ?? 0;
    const maxCraft = Math.min(maxByPlank, maxByStick);
    quickSwordBtn.disabled = maxCraft <= 0;
    quickSwordBtn.textContent = maxCraft > 0
      ? `Kiếm gỗ: 2 Plank + 1 Stick → 1 Kiếm (tối đa ${maxCraft})`
      : 'Kiếm gỗ: cần 2 Plank + 1 Stick';
    quickSwordBtn.onclick = () => {
      const maxByPl = Math.floor((inventory.plank ?? 0) / 2);
      const maxBySt = inventory.stick ?? 0;
      const maxNow = Math.min(maxByPl, maxBySt);
      if(maxNow <= 0) return;
      inventory.plank -= maxNow * 2;
      inventory.stick -= maxNow;
      inventory.wood_sword += maxNow;
      if(inventory.wood_sword > 0) hasWoodSword = true;
      renderInventory();
    };
  }
}

function setInventoryOpen(open){
  inventoryOpen = open;
  const root = document.getElementById('inventory');
  if(!root) return;
  root.style.display = open ? 'flex' : 'none';
  if(open){
    renderInventory();
    if(controls.isLocked){
      controls.unlock();
    }
  }
}

if(ui.invBtn){
  ui.invBtn.addEventListener('click', () => {
    setInventoryOpen(!inventoryOpen);
  });
}

/* ================== SIMPLE NOISE ================== */
function hash2(x, z){
  let n = (x * 374761393 + z * 668265263) ^ (x * 1274126177);
  n = (n ^ (n >> 13)) * 1274126177;
  n = (n ^ (n >> 16)) >>> 0;
  return n / 4294967296;
}
function lerp(a,b,t){ return a + (b - a) * t; }
function smooth(t){ return t * t * (3 - 2 * t); }
function valueNoise2(x, z){
  const xi = Math.floor(x), zi = Math.floor(z);
  const xf = x - xi, zf = z - zi;
  const a = hash2(xi, zi);
  const b = hash2(xi + 1, zi);
  const c = hash2(xi, zi + 1);
  const d = hash2(xi + 1, zi + 1);
  const u = smooth(xf);
  const v = smooth(zf);
  return lerp(lerp(a, b, u), lerp(c, d, u), v);
}
function fbm2(x, z){
  let amp = 1;
  let freq = 0.06;
  let sum = 0;
  let norm = 0;
  for(let i=0;i<4;i++){
    sum += valueNoise2(x * freq, z * freq) * amp;
    norm += amp;
    amp *= 0.5;
    freq *= 2;
  }
  return sum / norm;
}

/* ================== GENERATE WORLD (CHUNK VÔ HẠN) ================== */
// Sinh địa hình theo chunk quanh người chơi (map thực tế là vô hạn)
const CHUNK_SIZE = 16;
const VIEW_DISTANCE_CHUNKS = 3; // bán kính chunk quanh người chơi (giảm để nhẹ hơn)
const WORLD_MAX_H = 18;
const SEA_LEVEL = 6;

function heightAt(x, z){
  const n = fbm2(x + 1000, z + 1000); // 0..1
  const h = Math.floor(SEA_LEVEL + n * 10);
  return Math.max(2, Math.min(WORLD_MAX_H - 1, h));
}

function tryPlaceTree(x, y, z, keyList){
  for(let i=1;i<=4;i++){
    addBlock(x, y + i, z, BlockType.WOOD);
    if(keyList) keyList.push(key(x, y + i, z));
  }
  const topY = y + 4;
  for(let dx=-2;dx<=2;dx++){
    for(let dz=-2;dz<=2;dz++){
      for(let dy=-2;dy<=1;dy++){
        const dist = Math.abs(dx) + Math.abs(dz) + Math.abs(dy);
        if(dist > 4) continue;
        const lx = x + dx, ly = topY + dy, lz = z + dz;
        if(getBlock(lx, ly, lz)) continue;
        addBlock(lx, ly, lz, BlockType.LEAVES);
        if(keyList) keyList.push(key(lx, ly, lz));
      }
    }
  }
}

function loadChunk(cx, cz){
  const chunkKey = `${cx},${cz}`;
  if(loadedChunks.has(chunkKey)) return;
  loadedChunks.add(chunkKey);
  const keys = [];

  for(let lx=0; lx<CHUNK_SIZE; lx++){
    const wx = cx * CHUNK_SIZE + lx;
    for(let lz=0; lz<CHUNK_SIZE; lz++){
      const wz = cz * CHUNK_SIZE + lz;

      // lớp bedrock ở dưới cùng để không rơi khỏi map
      for(let by=-3; by<=-1; by++){
        addBlock(wx, by, wz, BlockType.BEDROCK);
        keys.push(key(wx, by, wz));
      }

      const h = heightAt(wx, wz);

      for(let y=0;y<=h;y++){
        const isTop = (y === h);
        const isNearTop = (y >= h - 3);
        let type = BlockType.STONE;
        if(isTop) type = (h <= SEA_LEVEL + 1) ? BlockType.SAND : BlockType.GRASS;
        else if(isNearTop) type = BlockType.DIRT;
        addBlock(wx, y, wz, type);
        keys.push(key(wx, y, wz));
      }

      const topType = getBlock(wx, h, wz);
      // cây xuất hiện dày và có cụm hơn
      if(topType === BlockType.GRASS && hash2(wx + 99, wz + 99) > 0.82){
        tryPlaceTree(wx, h, wz, keys);
      }

      // fill low areas with water (simple lakes / biển)
      const n = fbm2(wx * 0.4, wz * 0.4); // nhiễu phụ để tạo hồ/rạch
      if(h < SEA_LEVEL - 1 && n < 0.45){
        for(let wy=h+1; wy<=SEA_LEVEL; wy++){
          addBlock(wx, wy, wz, BlockType.WATER);
          keys.push(key(wx, wy, wz));
        }
      }
    }
  }

  chunkBlocks.set(chunkKey, keys);
}

function unloadChunk(chunkKey){
  if(!loadedChunks.has(chunkKey)) return;
  loadedChunks.delete(chunkKey);
  const keys = chunkBlocks.get(chunkKey);
  if(keys){
    for(const k of keys){
      world.delete(k);
    }
  }
  chunkBlocks.delete(chunkKey);
  renderDirty = true;
}

let lastChunkCenter = { cx: null, cz: null };

function updateChunksAroundPlayer(){
  const p = controls.getObject().position;
  const cxCenter = Math.floor(p.x / CHUNK_SIZE);
  const czCenter = Math.floor(p.z / CHUNK_SIZE);

  if(cxCenter === lastChunkCenter.cx && czCenter === lastChunkCenter.cz && loadedChunks.size > 0){
    return;
  }
  lastChunkCenter.cx = cxCenter;
  lastChunkCenter.cz = czCenter;

  const needed = new Set();
  const maxR2 = VIEW_DISTANCE_CHUNKS * VIEW_DISTANCE_CHUNKS;
  for(let dz=-VIEW_DISTANCE_CHUNKS; dz<=VIEW_DISTANCE_CHUNKS; dz++){
    for(let dx=-VIEW_DISTANCE_CHUNKS; dx<=VIEW_DISTANCE_CHUNKS; dx++){
      // chỉ load các chunk nằm trong hình tròn quanh người chơi
      if(dx*dx + dz*dz > maxR2) continue;
      const cx = cxCenter + dx;
      const cz = czCenter + dz;
      const ck = `${cx},${cz}`;
      needed.add(ck);
      loadChunk(cx, cz);
    }
  }

  for(const ck of Array.from(loadedChunks)){
    if(!needed.has(ck)){
      unloadChunk(ck);
    }
  }
}

// spawn ở gần (0,0) và load chunk xung quanh
controls.getObject().position.set(0, 30, 0);
updateChunksAroundPlayer();

/* ================== INPUT ================== */
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if(e.code.startsWith('Digit')){
    const n = Number(e.code.replace('Digit',''));
    if(n >= 1 && n <= blockPalette.length){
      selectedSlot = n - 1;
      renderHotbar();
    }
  }

  // mở / đóng túi đồ
  if(e.code === 'KeyI'){
    setInventoryOpen(!inventoryOpen);
  }
});
document.addEventListener('keyup', e => keys[e.code] = false);
window.addEventListener('contextmenu', e => e.preventDefault());

/* ================== PLAYER PHYSICS ================== */
const player = {
  radius: 0.35,
  height: 1.8,
  eyeHeight: 1.62,
  onGround: false,
  vel: new THREE.Vector3(0, 0, 0),
};

const GRAVITY = 22;
const JUMP_V = 9.0;      // lực nhảy mạnh hơn
const WALK_SPEED = 6.2;  // tốc độ đi bộ
const RUN_SPEED = 12.5;  // tốc độ chạy khi giữ Shift
const FRICTION_GROUND = 14;
const FRICTION_AIR = 1.5;

function playerFeetPos(){
  const p = controls.getObject().position;
  return new THREE.Vector3(p.x, p.y - player.eyeHeight, p.z);
}

function setPlayerFeetPos(feet){
  const p = controls.getObject().position;
  p.set(feet.x, feet.y + player.eyeHeight, feet.z);
}

function aabbIntersectsPlayer(blockX, blockY, blockZ, feet){
  const minX = blockX - 0.5, maxX = blockX + 0.5;
  const minY = blockY - 0.5, maxY = blockY + 0.5;
  const minZ = blockZ - 0.5, maxZ = blockZ + 0.5;

  const pMinX = feet.x - player.radius, pMaxX = feet.x + player.radius;
  const pMinY = feet.y, pMaxY = feet.y + player.height;
  const pMinZ = feet.z - player.radius, pMaxZ = feet.z + player.radius;

  return (
    pMinX < maxX && pMaxX > minX &&
    pMinY < maxY && pMaxY > minY &&
    pMinZ < maxZ && pMaxZ > minZ
  );
}

function resolveCollisions(feet, axis){
  const minX = Math.floor(feet.x - player.radius - 1);
  const maxX = Math.floor(feet.x + player.radius + 1);
  const minY = Math.floor(feet.y - 1);
  const maxY = Math.floor(feet.y + player.height + 1);
  const minZ = Math.floor(feet.z - player.radius - 1);
  const maxZ = Math.floor(feet.z + player.radius + 1);

  for(let x=minX;x<=maxX;x++){
    for(let y=minY;y<=maxY;y++){
      for(let z=minZ;z<=maxZ;z++){
        const t = getBlock(x,y,z);
        if(!t || t === BlockType.WATER) continue; // nước không chặn va chạm
        if(!aabbIntersectsPlayer(x,y,z,feet)) continue;

        const bxMin = x - 0.5, bxMax = x + 0.5;
        const byMin = y - 0.5, byMax = y + 0.5;
        const bzMin = z - 0.5, bzMax = z + 0.5;

        const pMinX = feet.x - player.radius, pMaxX = feet.x + player.radius;
        const pMinY = feet.y, pMaxY = feet.y + player.height;
        const pMinZ = feet.z - player.radius, pMaxZ = feet.z + player.radius;

        if(axis === 'x'){
          const pushLeft = bxMin - pMaxX;
          const pushRight = bxMax - pMinX;
          if(Math.abs(pushLeft) < Math.abs(pushRight)) feet.x += pushLeft;
          else feet.x += pushRight;
          player.vel.x = 0;
        } else if(axis === 'z'){
          const pushBack = bzMin - pMaxZ;
          const pushFront = bzMax - pMinZ;
          if(Math.abs(pushBack) < Math.abs(pushFront)) feet.z += pushBack;
          else feet.z += pushFront;
          player.vel.z = 0;
        } else if(axis === 'y'){
          const pushDown = byMin - pMaxY;
          const pushUp = byMax - pMinY;
          if(Math.abs(pushDown) < Math.abs(pushUp)){
            feet.y += pushDown;
            if(player.vel.y <= 0) player.onGround = true;
          } else {
            feet.y += pushUp;
          }
          player.vel.y = 0;
        }
      }
    }
  }
}

function collideAndMove(feet, deltaMove){
  const out = feet.clone();
  player.onGround = false;
  out.x += deltaMove.x; resolveCollisions(out, 'x');
  out.z += deltaMove.z; resolveCollisions(out, 'z');
  out.y += deltaMove.y; resolveCollisions(out, 'y');
  return out;
}

/* ================== VOXEL RAYCAST (DDA) ================== */
function voxelRaycast(origin, dir, maxDist){
  let x = Math.floor(origin.x);
  let y = Math.floor(origin.y);
  let z = Math.floor(origin.z);

  const stepX = dir.x > 0 ? 1 : -1;
  const stepY = dir.y > 0 ? 1 : -1;
  const stepZ = dir.z > 0 ? 1 : -1;

  const tDeltaX = dir.x === 0 ? Infinity : Math.abs(1 / dir.x);
  const tDeltaY = dir.y === 0 ? Infinity : Math.abs(1 / dir.y);
  const tDeltaZ = dir.z === 0 ? Infinity : Math.abs(1 / dir.z);

  const fracX = origin.x - Math.floor(origin.x);
  const fracY = origin.y - Math.floor(origin.y);
  const fracZ = origin.z - Math.floor(origin.z);

  let tMaxX = dir.x > 0 ? (1 - fracX) * tDeltaX : fracX * tDeltaX;
  let tMaxY = dir.y > 0 ? (1 - fracY) * tDeltaY : fracY * tDeltaY;
  let tMaxZ = dir.z > 0 ? (1 - fracZ) * tDeltaZ : fracZ * tDeltaZ;

  let t = 0;
  let lastStepAxis = null;

  while(t <= maxDist){
    const tBlock = getBlock(x, y, z);
    if(tBlock){
      let normal = new THREE.Vector3(0,0,0);
      // mặt đang nhìn tới (để đặt block) nằm cùng hướng với tia
      if(lastStepAxis === null){
        // chọn trục mạnh nhất của tia để xác định mặt
        const ax = Math.abs(dir.x), ay = Math.abs(dir.y), az = Math.abs(dir.z);
        if(ax >= ay && ax >= az) normal.set(stepX, 0, 0);
        else if(ay >= ax && ay >= az) normal.set(0, stepY, 0);
        else normal.set(0, 0, stepZ);
      }else{
        if(lastStepAxis === 'x') normal.set(stepX, 0, 0);
        if(lastStepAxis === 'y') normal.set(0, stepY, 0);
        if(lastStepAxis === 'z') normal.set(0, 0, stepZ);
      }

      // vị trí nên đặt block: phía xa hơn block theo hướng normal
      const place = {
        x: x + normal.x,
        y: y + normal.y,
        z: z + normal.z,
      };

      return { hit: { x, y, z }, place, normal };
    }

    if(tMaxX < tMaxY){
      if(tMaxX < tMaxZ){
        x += stepX; t = tMaxX; tMaxX += tDeltaX; lastStepAxis = 'x';
      } else {
        z += stepZ; t = tMaxZ; tMaxZ += tDeltaZ; lastStepAxis = 'z';
      }
    } else {
      if(tMaxY < tMaxZ){
        y += stepY; t = tMaxY; tMaxY += tDeltaY; lastStepAxis = 'y';
      } else {
        z += stepZ; t = tMaxZ; tMaxZ += tDeltaZ; lastStepAxis = 'z';
      }
    }
  }

  return null;
}

function getLookTarget(){
  const origin = camera.getWorldPosition(new THREE.Vector3());
  const dir = camera.getWorldDirection(new THREE.Vector3()).normalize();
  return voxelRaycast(origin, dir, 7.5);
}

function canPlaceAt(x,y,z){
  if(getBlock(x,y,z)) return false;
  const feet = playerFeetPos();
  return !aabbIntersectsPlayer(x,y,z,feet);
}

/* ================== PLAYER ATTACK ================== */
const mobRaycaster = new THREE.Raycaster();

function tryAttackMob(){
  const now = worldTime;
  if(now - lastAttackTimePlayer < ATTACK_COOLDOWN) return false;
  if(mobs.length === 0) return false;

  mobRaycaster.setFromCamera({ x: 0, y: 0 }, camera);
  const meshes = mobs.map(m => m.mesh);
  const hits = mobRaycaster.intersectObjects(meshes, true);
  if(!hits.length) return false;

  const hit = hits[0];
  if(hit.distance > 4) return false;

  // tìm mob tương ứng với mesh bị trúng
  let hitMesh = hit.object;
  let mob = mobs.find(m => m.mesh === hitMesh);
  if(!mob){
    // có thể trúng head/body, parent là group
    hitMesh = hitMesh.parent;
    mob = mobs.find(m => m.mesh === hitMesh);
  }
  if(!mob) return false;

  lastAttackTimePlayer = now;
  const baseDamage = hasWoodSword ? 8 : 3;
  mob.hp -= baseDamage;

  // knockback nhẹ
  const p = controls.getObject().position;
  const mpos = mob.mesh.position;
  const dx = mpos.x - p.x;
  const dz = mpos.z - p.z;
  const dist = Math.hypot(dx, dz) || 1;
  const knock = 0.8;
  mob.mesh.position.x += (dx / dist) * knock;
  mob.mesh.position.z += (dz / dist) * knock;

  // feedback nhẹ cho người chơi
  triggerHitOverlay();

  return true;
}

/* ================== MOUSE ACTION ================== */
window.addEventListener('mousedown', e => {
  if(inventoryOpen) return;
  if(!controls.isLocked) return;
  const target = getLookTarget();

  if(e.button === 0){
    // ưu tiên đánh zombie, nếu không trúng mới phá block
    if(tryAttackMob()) return;
    if(!target) return;
    const removedType = removeBlockAt(target.hit.x, target.hit.y, target.hit.z);
    // phá block gỗ thân cây → cho log vào túi
    if(removedType === BlockType.WOOD){
      inventory.log += 1;
    }
  }

  if(e.button === 2){
    if(!target) return;
    const p = target.place;
    const type = blockPalette[selectedSlot]?.type ?? BlockType.GRASS;
    if(canPlaceAt(p.x, p.y, p.z)) addBlock(p.x, p.y, p.z, type);
  }
});

/* ================== MOVEMENT ================== */
const moveDir = new THREE.Vector3();
let jumpHeld = false;
function updateMovement(delta){
  if(inventoryOpen) return;
  const feet = playerFeetPos();

  moveDir.set(0, 0, 0);
  if(keys['KeyW']) moveDir.z += 1;
  if(keys['KeyS']) moveDir.z -= 1;
  if(keys['KeyA']) moveDir.x -= 1;
  if(keys['KeyD']) moveDir.x += 1;
  if(moveDir.lengthSq() > 0) moveDir.normalize();

  const speed = (keys['ShiftLeft'] || keys['ShiftRight']) ? RUN_SPEED : WALK_SPEED;

  const yawObject = controls.getObject();
  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
  forward.y = 0; forward.normalize();
  const right = new THREE.Vector3(1, 0, 0).applyQuaternion(yawObject.quaternion);
  right.y = 0; right.normalize();

  const desired = new THREE.Vector3()
    .addScaledVector(forward, moveDir.z)
    .addScaledVector(right, moveDir.x);
  if(desired.lengthSq() > 0) desired.normalize().multiplyScalar(speed);

  // Không giữ quán tính ngang: di chuyển dừng ngay khi nhả phím
  const horizMove = desired.clone().multiplyScalar(delta);
  player.vel.x = 0;
  player.vel.z = 0;

  player.vel.y -= GRAVITY * delta;

  // kiểm tra chỉ nhảy một lần khi vừa nhấn Space
  const justPressedJump = keys['Space'] && !jumpHeld;
  jumpHeld = keys['Space'];

  // kiểm tra có block ngay dưới chân (ổn định hơn onGround)
  let grounded = false;
  const groundY = Math.floor(feet.y - 0.05);
  for(let ox=-0.25; ox<=0.25; ox+=0.25){
    for(let oz=-0.25; oz<=0.25; oz+=0.25){
      const gx = Math.round(feet.x + ox);
      const gz = Math.round(feet.z + oz);
      const t = getBlock(gx, groundY, gz);
      if(t && t !== BlockType.WATER){ grounded = true; break; }
    }
    if(grounded) break;
  }

  if(justPressedJump && grounded){
    player.vel.y = JUMP_V;
    player.onGround = false;
  }

  const deltaMove = new THREE.Vector3(horizMove.x, player.vel.y * delta, horizMove.z);
  const nextFeet = collideAndMove(feet, deltaMove);
  setPlayerFeetPos(nextFeet);
}

/* ================== LOOP ================== */
let prevTime = performance.now();
let worldTime = 0; // giây trong game
let fpsAcc = 0, fpsCount = 0, fps = 0;

function animate(){
  requestAnimationFrame(animate);
  const time = performance.now();
  const delta = (time - prevTime) / 1000;
  worldTime += delta;

  // cập nhật chunk (map gần như vô hạn, chỉ giữ vùng quanh người chơi)
  updateChunksAroundPlayer();

  // ====== Day / Night cycle ======
  // 1 ngày = 240 giây (4 phút)
  const DAY_LENGTH = 240;
  const tDay = (worldTime % DAY_LENGTH) / DAY_LENGTH; // 0..1
  // góc mặt trời quay quanh người chơi
  const angle = tDay * Math.PI * 2;
  const radius = 80;

  // vị trí mặt trời / mặt trăng
  const centerX = 0;
  const centerZ = 0;
  const sunY = Math.sin(angle) * radius * 0.6;
  const sunX = centerX + Math.cos(angle) * radius;
  const sunZ = centerZ + Math.sin(angle) * radius;

  sun.position.set(sunX, sunY, sunZ);
  sunSphere.position.copy(sun.position);

  const moonAngle = angle + Math.PI;
  const moonY = Math.sin(moonAngle) * radius * 0.6;
  const moonX = centerX + Math.cos(moonAngle) * radius;
  const moonZ = centerZ + Math.sin(moonAngle) * radius;
  moonSphere.position.set(moonX, moonY, moonZ);

  // độ cao mặt trời -> độ sáng
  const sunHeight01 = Math.max(0, sunY / (radius * 0.6)); // 0..1 khi trên đường chân trời
  // làm đường cong mượt: ban ngày sáng, ban đêm rất tối
  const brightness = Math.max(0.04, Math.pow(sunHeight01, 1.4));

  hemi.intensity = 0.25 + brightness * 0.6;
  sun.intensity = 0.1 + brightness * 1.3;

  // nội suy màu trời
  const sky = daySky.clone().lerp(nightSky, 1 - brightness);
  scene.background.copy(sky);
  scene.fog.color.copy(sky);

  // cập nhật mob (zombie)
  updateMobs(delta);
  trySpawnMobs(delta);
  updateProjectiles(delta);

  if(renderDirty){
    rebuildInstances();
    renderDirty = false;
  }

  if(controls.isLocked){
    updateMovement(delta);
  }

  const target = getLookTarget();
  if(target){
    outline.visible = true;
    outline.position.set(target.hit.x, target.hit.y, target.hit.z);
  } else {
    outline.visible = false;
  }

  fpsAcc += delta;
  fpsCount++;
  if(fpsAcc >= 0.35){
    fps = Math.round(fpsCount / fpsAcc);
    fpsAcc = 0; fpsCount = 0;
  }
  const p = controls.getObject().position;
  ui.stats.textContent =
`FPS: ${fps}
X: ${p.x.toFixed(1)}  Y: ${p.y.toFixed(1)}  Z: ${p.z.toFixed(1)}
Blocks: ${world.size}
HP: ${playerHP}
Log: ${inventory.log}  Plank: ${inventory.plank}  Stick: ${inventory.stick}
Flesh: ${inventory.rotten_flesh}  Sword: ${inventory.wood_sword}`;

  renderHPBar();

  renderer.render(scene, camera);
  prevTime = time;
}
animate();

/* ================== RESIZE ================== */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
