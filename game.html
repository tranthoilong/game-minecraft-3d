<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíù T·∫∑ng Em Y√™u üíù</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 30px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #e91e63;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 240, 245, 0.98) 100%);
            padding: 40px 60px;
            border-radius: 30px;
            font-size: 32px;
            font-weight: bold;
            color: #e91e63;
            text-align: center;
            box-shadow: 0 15px 50px rgba(233, 30, 99, 0.3), 0 0 30px rgba(255, 20, 147, 0.2);
            opacity: 0;
            max-width: 85%;
            line-height: 1.8;
            z-index: 500;
            pointer-events: none;
            border: 3px solid rgba(255, 20, 147, 0.4);
        }

        #message.show {
            animation: messageAppear 0.5s ease-out forwards;
        }

        #message.hide {
            animation: messageDisappear 0.4s ease-in forwards;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 16px;
            color: #333;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        #startScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
        }

        #startScreen p {
            font-size: 20px;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
        }

        #startButton {
            padding: 20px 50px;
            font-size: 24px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transition: transform 0.3s, box-shadow 0.3s;
            pointer-events: all;
            font-weight: bold;
        }

        #startButton:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes messageAppear {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes messageDisappear {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }

        #completion {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        #completion.show {
            display: flex;
        }

        #completion h1 {
            font-size: 56px;
            margin-bottom: 30px;
            text-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
        }

        #completion p {
            font-size: 24px;
            text-align: center;
            max-width: 700px;
            line-height: 1.8;
            margin-bottom: 20px;
        }

        /* Mobile Controls */
        #mobileControls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 250px;
            pointer-events: none;
            z-index: 200;
            display: none;
        }

        #mobileControls.show {
            display: block;
        }

        #joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            pointer-events: all;
        }

        #joystickBase {
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
        }

        #joystickStick {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            position: absolute;
            left: 45px;
            top: 45px;
            transition: all 0.1s;
        }

        #actionButtons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            pointer-events: all;
        }

        .actionBtn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            margin: 10px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            touch-action: none;
            user-select: none;
        }

        .actionBtn:active {
            background: rgba(255, 255, 255, 0.8);
            transform: scale(0.95);
        }

        #upBtn {
            position: absolute;
            right: 0;
            bottom: 90px;
        }

        #downBtn {
            position: absolute;
            right: 0;
            bottom: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #score {
                top: 10px;
                right: 10px;
                padding: 10px 20px;
                font-size: 18px;
            }

            #message {
                font-size: 22px;
                padding: 25px 35px;
                max-width: 90%;
            }

            #instructions {
                display: none;
            }

            #startScreen h1 {
                font-size: 36px;
            }

            #startScreen p {
                font-size: 16px;
                padding: 0 20px;
            }

            #startButton {
                padding: 15px 40px;
                font-size: 20px;
            }

            #hint {
                font-size: 16px;
                padding: 10px 20px;
                top: 80px;
            }

            #directionArrow {
                font-size: 50px;
            }
        }

        #hint {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 18px;
            color: #e91e63;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        #hint.show {
            opacity: 1;
        }

        #directionArrow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: rgba(255, 20, 147, 0.7);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 20px rgba(255, 20, 147, 0.8);
        }

        #directionArrow.show {
            opacity: 1;
        }

        #messageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            z-index: 450;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #messageOverlay.show {
            opacity: 1;
        }

        @keyframes sparkle {
            0%, 100% {
                opacity: 0;
                transform: scale(0);
            }
            50% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .sparkle {
            position: fixed;
            font-size: 20px;
            pointer-events: none;
            z-index: 550;
            animation: sparkle 1.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>üíù D√†nh T·∫∑ng Em Y√™u üíù</h1>
        <p id="startDescription">
            Anh ƒë√£ t·∫°o ra th·∫ø gi·ªõi 3D n√†y d√†nh ri√™ng cho em.<br>
            H√£y bay trong kh√¥ng gian v√† thu th·∫≠p t·∫•t c·∫£ nh·ªØng tr√°i tim,<br>
            m·ªói tr√°i tim ƒë·ªÅu ch·ª©a m·ªôt l·ªùi nh·∫Øn t·ª´ tr√°i tim anh. üíï
        </p>
        <button id="startButton">B·∫Øt ƒê·∫ßu Kh√°m Ph√° üíñ</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="score">‚ù§Ô∏è Tr√°i Tim: 0/10</div>
        <div id="hint"></div>
        <div id="directionArrow"></div>
        <div id="instructions">
            üéÆ Di chuy·ªÉn: W/A/S/D ho·∫∑c ‚Üë/‚Üê/‚Üì/‚Üí | üñ±Ô∏è Xoay: Chu√≥t | üöÄ Bay l√™n/xu·ªëng: Space/Shift
        </div>
    </div>

    <div id="messageOverlay"></div>
    <div id="message"></div>

    <div id="mobileControls">
        <div id="joystick">
            <div id="joystickBase"></div>
            <div id="joystickStick"></div>
        </div>
        <div id="actionButtons">
            <div id="upBtn" class="actionBtn">‚Üë</div>
            <div id="downBtn" class="actionBtn">‚Üì</div>
        </div>
    </div>

    <div id="completion">
        <h1>üíï Em ƒê√£ Thu Th·∫≠p ƒê·ªß T·∫•t C·∫£! üíï</h1>
        <p>
            Anh y√™u em nhi·ªÅu l·∫Øm! ‚ù§Ô∏è<br>
            Em l√† √°nh s√°ng trong cu·ªôc ƒë·ªùi anh,<br>
            l√† l√Ω do anh m·ªâm c∆∞·ªùi m·ªói ng√†y.<br>
            C·∫£m ∆°n em ƒë√£ ƒë·∫øn b√™n anh! üåπ<br><br>
            <strong>I Love You Forever! üíñ</strong>
        </p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer;
        let hearts = [];
        let particles = [];
        let score = 0;
        const totalHearts = 7; // Gi·∫£m xu·ªëng ƒë·ªÉ game m∆∞·ª£t h∆°n
        let gameStarted = false;

        // Device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        ('ontouchstart' in window) || 
                        (window.innerWidth <= 768);

        // Movement variables
        const movement = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false
        };

        const velocity = new THREE.Vector3();
        const moveSpeed = isMobile ? 0.2 : 0.3; // Ch·∫≠m h∆°n tr√™n mobile
        const rotateSpeed = isMobile ? 0.002 : 0.0015; // Gi·∫£m ƒë·ªô nh·∫°y ƒë·ªÉ ·ªïn ƒë·ªãnh h∆°n

        // Mouse movement
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;

        // Mobile controls
        let joystickActive = false;
        let joystickStart = { x: 0, y: 0 };
        let joystickCurrent = { x: 0, y: 0 };
        let touchStartX = 0, touchStartY = 0;

        // Hint system
        let nearestHeart = null;
        let lastHintTime = 0;

        // Love messages
        const loveMessages = [
            "üíï Anh y√™u em nhi·ªÅu l·∫Øm!",
            "üåπ Em l√† ƒëi·ªÅu tuy·ªát v·ªùi nh·∫•t trong ƒë·ªùi anh!",
            "‚ú® M·ªói ng√†y b√™n em ƒë·ªÅu l√† m·ªôt m√≥n qu√†!",
            "üíñ Em l√†m cu·ªôc s·ªëng anh √Ω nghƒ©a h∆°n!",
            "üåü Anh mu·ªën ƒë∆∞·ª£c ·ªü b√™n em m√£i m√£i!",
            "üíù Em l√† t√¨nh y√™u c·ªßa ƒë·ªùi anh!",
            "üéÄ C·∫£m ∆°n em ƒë√£ ƒë·∫øn b√™n anh!",
            "üí´ Em xinh ƒë·∫πp nh·∫•t tr·∫ßn ƒë·ªùi!",
            "üå∏ Anh h·∫°nh ph√∫c v√¨ c√≥ em!",
            "üíó Y√™u em 3000! I Love You Forever!"
        ];

        // Initialize game
        function init() {
            // Update instructions based on device
            if (isMobile) {
                document.getElementById('startDescription').innerHTML = 
                    'Anh ƒë√£ t·∫°o ra th·∫ø gi·ªõi 3D n√†y d√†nh ri√™ng cho em.<br>' +
                    'D√πng joystick ƒë·ªÉ di chuy·ªÉn, ch·∫°m m√†n h√¨nh ƒë·ªÉ nh√¨n xung quanh,<br>' +
                    'v√† thu th·∫≠p t·∫•t c·∫£ nh·ªØng tr√°i tim ch·ª©a l·ªùi nh·∫Øn y√™u th∆∞∆°ng! üíï';
            }

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Add point lights for atmosphere
            const pointLight1 = new THREE.PointLight(0xff69b4, 1, 50);
            pointLight1.position.set(-10, 5, -10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff1493, 1, 50);
            pointLight2.position.set(10, 5, 10);
            scene.add(pointLight2);

            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90ee90,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create hearts
            for (let i = 0; i < totalHearts; i++) {
                createHeart(i);
            }

            // Create floating particles
            createParticles();

            // Create sky box with gradient
            createSkybox();

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.getElementById('startButton').addEventListener('click', startGame);

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function createHeart(index) {
            const heartShape = new THREE.Shape();
            const x = 0, y = 0;
            heartShape.moveTo(x + 0.5, y + 0.5);
            heartShape.bezierCurveTo(x + 0.5, y + 0.5, x + 0.4, y, x, y);
            heartShape.bezierCurveTo(x - 0.6, y, x - 0.6, y + 0.7, x - 0.6, y + 0.7);
            heartShape.bezierCurveTo(x - 0.6, y + 1.1, x - 0.3, y + 1.54, x + 0.5, y + 1.9);
            heartShape.bezierCurveTo(x + 1.2, y + 1.54, x + 1.6, y + 1.1, x + 1.6, y + 0.7);
            heartShape.bezierCurveTo(x + 1.6, y + 0.7, x + 1.6, y, x + 1.0, y);
            heartShape.bezierCurveTo(x + 0.7, y, x + 0.5, y + 0.5, x + 0.5, y + 0.5);

            const extrudeSettings = {
                depth: 0.3,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 2,
                bevelSize: 0.1,
                bevelThickness: 0.1
            };

            const geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff1493,
                emissive: 0xff1493,
                emissiveIntensity: 0.8, // S√°ng h∆°n
                metalness: 0.3,
                roughness: 0.1
            });

            const heart = new THREE.Mesh(geometry, material);
            
            // Xoay mesh tr√°i tim ƒë·ªÉ ƒë·ªânh h∆∞·ªõng xu·ªëng d∆∞·ªõi (ƒë√∫ng h∆∞·ªõng)
            heart.rotation.z = Math.PI; // Xoay 180 ƒë·ªô
            heart.scale.set(0.3, 0.3, 0.3);
            heart.castShadow = true;
            
            // T·∫°o group ƒë·ªÉ ch·ª©a tr√°i tim (tr√°nh xoay l·ªôn x·ªôn)
            const heartGroup = new THREE.Group();
            heartGroup.add(heart);
            
            // Random position cho group
            const angle = (index / totalHearts) * Math.PI * 2;
            const radius = 15 + Math.random() * 10;
            heartGroup.position.x = Math.cos(angle) * radius;
            heartGroup.position.y = 2 + Math.random() * 8;
            heartGroup.position.z = Math.sin(angle) * radius;
            
            // Th√™m √°nh s√°ng ƒëi·ªÉm v√†o m·ªói tr√°i tim ƒë·ªÉ d·ªÖ th·∫•y h∆°n
            const heartLight = new THREE.PointLight(0xff1493, 2, 10);
            heartLight.position.copy(heartGroup.position);
            scene.add(heartLight);
            
            // L∆∞u th√¥ng tin v√†o group thay v√¨ heart
            heartGroup.userData.collected = false;
            heartGroup.userData.initialY = heartGroup.position.y;
            heartGroup.userData.rotationSpeed = 0.02 + Math.random() * 0.02;
            heartGroup.userData.floatSpeed = 0.5 + Math.random() * 0.5;
            heartGroup.userData.light = heartLight;
            heartGroup.userData.heartMesh = heart; // Reference ƒë·∫øn mesh b√™n trong

            scene.add(heartGroup);
            hearts.push(heartGroup);
        }

        function createParticles() {
            const particleCount = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = Math.random() * 50;
                positions[i + 2] = (Math.random() - 0.5) * 100;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0xffc0cb,
                size: 0.3,
                transparent: true,
                opacity: 0.8
            });

            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        function createSkybox() {
            // Add some clouds
            for (let i = 0; i < 20; i++) {
                const cloudGeometry = new THREE.SphereGeometry(3, 8, 8);
                const cloudMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(
                    (Math.random() - 0.5) * 100,
                    15 + Math.random() * 20,
                    (Math.random() - 0.5) * 100
                );
                cloud.scale.set(1 + Math.random(), 0.5, 1 + Math.random());
                scene.add(cloud);
            }
        }

        function startGame() {
            gameStarted = true;
            document.getElementById('startScreen').style.display = 'none';
            
            if (isMobile) {
                // Show mobile controls
                document.getElementById('mobileControls').classList.add('show');
                setupMobileControls();
            } else {
                // Request pointer lock for PC
                document.getElementById('gameCanvas').requestPointerLock();
            }
            
            animate();
        }

        function onKeyDown(event) {
            if (!gameStarted) return;
            
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    movement.forward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    movement.backward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    movement.left = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    movement.right = true;
                    break;
                case 'Space':
                    movement.up = true;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    movement.down = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    movement.forward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    movement.backward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    movement.left = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    movement.right = false;
                    break;
                case 'Space':
                    movement.up = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    movement.down = false;
                    break;
            }
        }

        function onMouseMove(event) {
            if (isMobile) return; // Disable mouse on mobile
            if (!gameStarted || document.pointerLockElement !== document.getElementById('gameCanvas')) return;
            
            mouseX = event.movementX || 0;
            mouseY = event.movementY || 0;
            
            // Gi·∫£m ƒë·ªô nh·∫°y ƒë·ªÉ camera ·ªïn ƒë·ªãnh, kh√¥ng l·∫Øc
            targetRotationY -= mouseX * rotateSpeed * 0.8;
            targetRotationX -= mouseY * rotateSpeed * 0.8;
            targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupMobileControls() {
            const joystickBase = document.getElementById('joystick');
            const joystickStick = document.getElementById('joystickStick');
            const canvas = document.getElementById('gameCanvas');

            // Joystick controls
            joystickBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                const rect = joystickBase.getBoundingClientRect();
                joystickStart.x = rect.left + rect.width / 2;
                joystickStart.y = rect.top + rect.height / 2;
            });

            joystickBase.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!joystickActive) return;

                const touch = e.touches[0];
                const deltaX = touch.clientX - joystickStart.x;
                const deltaY = touch.clientY - joystickStart.y;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = 45;
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    joystickCurrent.x = Math.cos(angle) * maxDistance;
                    joystickCurrent.y = Math.sin(angle) * maxDistance;
                } else {
                    joystickCurrent.x = deltaX;
                    joystickCurrent.y = deltaY;
                }

                joystickStick.style.transform = `translate(${joystickCurrent.x}px, ${joystickCurrent.y}px)`;

                // Update movement based on joystick
                const threshold = 10;
                movement.forward = joystickCurrent.y < -threshold;
                movement.backward = joystickCurrent.y > threshold;
                movement.left = joystickCurrent.x < -threshold;
                movement.right = joystickCurrent.x > threshold;
            });

            joystickBase.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystickCurrent.x = 0;
                joystickCurrent.y = 0;
                joystickStick.style.transform = 'translate(0, 0)';
                movement.forward = false;
                movement.backward = false;
                movement.left = false;
                movement.right = false;
            });

            // Up/Down buttons
            const upBtn = document.getElementById('upBtn');
            const downBtn = document.getElementById('downBtn');

            upBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                movement.up = true;
            });

            upBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                movement.up = false;
            });

            downBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                movement.down = true;
            });

            downBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                movement.down = false;
            });

            // Touch camera rotation for mobile
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;

                    // Gi·∫£m ƒë·ªô nh·∫°y cho m∆∞·ª£t h∆°n, kh√¥ng l·∫Øc
                    targetRotationY -= deltaX * rotateSpeed * 0.3;
                    targetRotationX -= deltaY * rotateSpeed * 0.3;
                    targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));

                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }
            });
        }

        function updateMovement() {
            // Khi bay l√™n/xu·ªëng, t·ª± ƒë·ªông san b·∫±ng camera v√† gi·ªØ ·ªïn ƒë·ªãnh
            if (movement.up || movement.down) {
                // Lerp v·ªÅ g√≥c 0 (nh√¨n th·∫≥ng) khi bay
                targetRotationX *= 0.85;
                // Gi·ªØ h∆∞·ªõng ngang ·ªïn ƒë·ªãnh khi bay (kh√¥ng cho xoay tr√°i ph·∫£i)
                targetRotationY = camera.rotation.y;
            }

            // Apply rotation to camera - smooth interpolation v·ªõi lerp cao h∆°n ƒë·ªÉ ·ªïn ƒë·ªãnh
            camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.2;
            camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.2;

            // T√≠nh to√°n h∆∞·ªõng di chuy·ªÉn d·ª±a tr√™n camera rotation (ch·ªâ Y, b·ªè qua X ƒë·ªÉ bay th·∫≥ng)
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            // Forward direction (h∆∞·ªõng nh√¨n, b·ªè qua g√≥c l√™n/xu·ªëng)
            forward.set(
                -Math.sin(camera.rotation.y), // ƒê·ªïi d·∫•u ƒë·ªÉ ƒëi ƒë√∫ng h∆∞·ªõng
                0,
                -Math.cos(camera.rotation.y)  // ƒê·ªïi d·∫•u ƒë·ªÉ ƒëi ƒë√∫ng h∆∞·ªõng
            );
            forward.normalize();
            
            // Right direction (vu√¥ng g√≥c v·ªõi forward)
            right.set(
                Math.cos(camera.rotation.y),  // Right = forward xoay 90 ƒë·ªô
                0,
                -Math.sin(camera.rotation.y)
            );
            right.normalize();

            // Di chuy·ªÉn camera
            if (movement.forward) {
                camera.position.addScaledVector(forward, moveSpeed);
            }
            if (movement.backward) {
                camera.position.addScaledVector(forward, -moveSpeed);
            }
            if (movement.right) {
                camera.position.addScaledVector(right, moveSpeed);
            }
            if (movement.left) {
                camera.position.addScaledVector(right, -moveSpeed);
            }
            if (movement.up) {
                camera.position.y += moveSpeed;
            }
            if (movement.down) {
                camera.position.y -= moveSpeed;
            }

            // Keep camera above ground
            if (camera.position.y < 0) camera.position.y = 0;
        }

        function checkHeartCollision() {
            const collisionDistance = isMobile ? 4 : 3; // D·ªÖ h∆°n tr√™n mobile
            let minDistance = Infinity;
            nearestHeart = null;

            hearts.forEach((heart, index) => {
                if (heart.userData.collected) return;

                const distance = camera.position.distanceTo(heart.position);
                
                // Track nearest heart for hint
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestHeart = heart;
                }

                // Check collision
                if (distance < collisionDistance) {
                    heart.userData.collected = true;
                    score++;
                    
                    // Update score display
                    document.getElementById('score').textContent = `‚ù§Ô∏è Tr√°i Tim: ${score}/${totalHearts}`;
                    
                    // Show message
                    showMessage(loveMessages[index]);
                    
                    // Remove heart with animation
                    animateHeartCollection(heart);
                    
                    // Check if all hearts collected
                    if (score === totalHearts) {
                        setTimeout(() => {
                            document.getElementById('completion').classList.add('show');
                        }, 2000);
                    }
                }
            });

            // Show hint to nearest heart
            updateHint(minDistance);
        }

        function updateHint(distance) {
            const hintEl = document.getElementById('hint');
            const arrowEl = document.getElementById('directionArrow');
            const now = Date.now();

            if (distance < 20 && nearestHeart) {
                const direction = new THREE.Vector3();
                direction.subVectors(nearestHeart.position, camera.position);
                direction.y = 0; // Ignore vertical distance
                
                const cameraDir = new THREE.Vector3();
                camera.getWorldDirection(cameraDir);
                cameraDir.y = 0;
                cameraDir.normalize();
                direction.normalize();

                const angle = Math.atan2(
                    direction.z * cameraDir.x - direction.x * cameraDir.z,
                    direction.x * cameraDir.x + direction.z * cameraDir.z
                );

                // Show arrow if heart is not directly visible
                if (Math.abs(angle) > Math.PI / 6) { // More than 30 degrees off center
                    let arrow = '';
                    if (Math.abs(angle) < Math.PI / 4) {
                        arrow = '‚Üë';
                    } else if (angle > Math.PI * 3 / 4 || angle < -Math.PI * 3 / 4) {
                        arrow = '‚Üì';
                    } else if (angle > 0) {
                        arrow = '‚Üê';
                    } else {
                        arrow = '‚Üí';
                    }
                    arrowEl.textContent = arrow;
                    arrowEl.classList.add('show');
                } else {
                    arrowEl.classList.remove('show');
                }

                // Text hint
                if (now - lastHintTime > 3000) { // Show hint every 3 seconds
                    let directionText = '';
                    if (Math.abs(angle) < Math.PI / 4) {
                        directionText = 'Ph√≠a tr∆∞·ªõc';
                    } else if (angle > Math.PI * 3 / 4 || angle < -Math.PI * 3 / 4) {
                        directionText = 'Ph√≠a sau';
                    } else if (angle > 0) {
                        directionText = 'B√™n tr√°i';
                    } else {
                        directionText = 'B√™n ph·∫£i';
                    }

                    const verticalHint = nearestHeart.position.y - camera.position.y;
                    if (Math.abs(verticalHint) > 2) {
                        directionText += verticalHint > 0 ? ' - Bay l√™n ‚Üë' : ' - Bay xu·ªëng ‚Üì';
                    }

                    hintEl.textContent = `üíù ${directionText} (${Math.round(distance)}m)`;
                    hintEl.classList.add('show');
                    lastHintTime = now;

                    setTimeout(() => {
                        hintEl.classList.remove('show');
                    }, 2500);
                }
            } else {
                arrowEl.classList.remove('show');
            }
        }

        function animateHeartCollection(heartGroup) {
            const heartMesh = heartGroup.userData.heartMesh;
            const startScale = heartMesh ? heartMesh.scale.clone() : new THREE.Vector3(0.3, 0.3, 0.3);
            const duration = 500;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;

                if (progress < 1) {
                    // Scale down the mesh inside the group
                    if (heartMesh) {
                        heartMesh.scale.lerpVectors(startScale, new THREE.Vector3(0, 0, 0), progress);
                    }
                    
                    // Rotate the group for spin effect
                    heartGroup.rotation.y += 0.1;
                    
                    // Fade out light
                    if (heartGroup.userData.light) {
                        heartGroup.userData.light.intensity = 2 * (1 - progress);
                    }
                    
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(heartGroup);
                    // Remove light
                    if (heartGroup.userData.light) {
                        scene.remove(heartGroup.userData.light);
                    }
                }
            }
            animate();
        }

        function showMessage(text) {
            const messageEl = document.getElementById('message');
            const overlayEl = document.getElementById('messageOverlay');
            
            // Remove any existing classes
            messageEl.classList.remove('show', 'hide');
            messageEl.textContent = text;
            
            // Trigger reflow to restart animation
            void messageEl.offsetWidth;
            
            // Show overlay and message with animation
            overlayEl.classList.add('show');
            messageEl.classList.add('show');
            
            // Create sparkles around the message
            createSparkles();
            
            // Hide after 3 seconds with fade out animation
            setTimeout(() => {
                messageEl.classList.remove('show');
                messageEl.classList.add('hide');
                overlayEl.classList.remove('show');
            }, 3200);
        }

        function createSparkles() {
            const sparkleEmojis = ['‚ú®', 'üíñ', 'üíù', 'üåü', '‚≠ê', 'üíï', 'üíó'];
            const numSparkles = 12;
            
            for (let i = 0; i < numSparkles; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                sparkle.textContent = sparkleEmojis[Math.floor(Math.random() * sparkleEmojis.length)];
                
                // Random position around the center
                const angle = (i / numSparkles) * Math.PI * 2;
                const distance = 150 + Math.random() * 100;
                const x = 50 + Math.cos(angle) * distance / window.innerWidth * 100;
                const y = 50 + Math.sin(angle) * distance / window.innerHeight * 100;
                
                sparkle.style.left = x + '%';
                sparkle.style.top = y + '%';
                sparkle.style.animationDelay = (i * 0.1) + 's';
                
                document.body.appendChild(sparkle);
                
                // Remove sparkle after animation
                setTimeout(() => {
                    sparkle.remove();
                }, 1500);
            }
        }

        function animate() {
            if (!gameStarted) return;
            
            requestAnimationFrame(animate);

            // Update movement
            updateMovement();

            // Animate hearts
            hearts.forEach((heartGroup, index) => {
                if (!heartGroup.userData.collected) {
                    // Xoay group theo tr·ª•c Y (kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn rotation.z c·ªßa mesh b√™n trong)
                    heartGroup.rotation.y += heartGroup.userData.rotationSpeed;
                    
                    // Float up and down
                    heartGroup.position.y = heartGroup.userData.initialY + 
                        Math.sin(Date.now() * 0.001 * heartGroup.userData.floatSpeed) * 0.5;
                    
                    // Pulsing effect - ch·ªâ scale mesh b√™n trong
                    const pulse = 1 + Math.sin(Date.now() * 0.003) * 0.15;
                    const heartMesh = heartGroup.userData.heartMesh;
                    if (heartMesh) {
                        heartMesh.scale.set(0.3 * pulse, 0.3 * pulse, 0.3 * pulse);
                    }
                    
                    // Update light position
                    if (heartGroup.userData.light) {
                        heartGroup.userData.light.position.copy(heartGroup.position);
                        // Pulsing light intensity
                        heartGroup.userData.light.intensity = 2 + Math.sin(Date.now() * 0.002) * 0.5;
                    }
                }
            });

            // Animate particles
            particles.forEach(particleSystem => {
                particleSystem.rotation.y += 0.0005;
            });

            // Check collisions
            checkHeartCollision();

            // Render scene
            renderer.render(scene, camera);
        }

        // Initialize game on load
        init();
    </script>
</body>
</html